/*
** DON'T EDIT THIS FILE **
It's been generated by Zapatos, and is liable to be overwritten

Zapatos: https://jawj.github.io/zapatos/
Copyright (C) 2020 - 2023 George MacKerron
Released under the MIT licence: see LICENCE file
*/

declare module 'zapatos/schema' {

  import type * as db from 'zapatos/db';

  // got a type error on schemaVersionCanary below? update by running `npx zapatos`
  export interface schemaVersionCanary extends db.SchemaVersionCanary { version: 104 }


  /* === schema: public === */

  /* --- enums --- */
  /* (none) */

  /* --- tables --- */

  /**
   * **earmarks**
   * - Table in database
   */
  export namespace earmarks {
    export type Table = 'earmarks';
    export interface Selectable {
      /**
      * **earmarks.createdAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      createdAt: Date | null;
      /**
      * **earmarks.designatedPurchaseChain**
      *
      * Designated chain ID for purchasing this invoice - the invoice destination chain that Mark has identified as the target for fund aggregation
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      designatedPurchaseChain: number;
      /**
      * **earmarks.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id: string;
      /**
      * **earmarks.invoiceId**
      *
      * External invoice identifier from the invoice processing system
      * - `text` in database
      * - `NOT NULL`, no default
      */
      invoiceId: string;
      /**
      * **earmarks.minAmount**
      *
      * Minimum amount of tokens required for invoice payment on the designated chain (stored as string to preserve precision)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      minAmount: string;
      /**
      * **earmarks.status**
      *
      * Earmark status: pending, ready, completed, cancelled (enforced by CHECK constraint)
      * - `text` in database
      * - `NOT NULL`, default: `'pending'::text`
      */
      status: string;
      /**
      * **earmarks.tickerHash**
      *
      * Token tickerHash (e.g., USDC, ETH) required for invoice payment
      * - `text` in database
      * - `NOT NULL`, no default
      */
      tickerHash: string;
      /**
      * **earmarks.updatedAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updatedAt: Date | null;
    }
    export interface JSONSelectable {
      /**
      * **earmarks.createdAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      createdAt: db.TimestampTzString | null;
      /**
      * **earmarks.designatedPurchaseChain**
      *
      * Designated chain ID for purchasing this invoice - the invoice destination chain that Mark has identified as the target for fund aggregation
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      designatedPurchaseChain: number;
      /**
      * **earmarks.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id: string;
      /**
      * **earmarks.invoiceId**
      *
      * External invoice identifier from the invoice processing system
      * - `text` in database
      * - `NOT NULL`, no default
      */
      invoiceId: string;
      /**
      * **earmarks.minAmount**
      *
      * Minimum amount of tokens required for invoice payment on the designated chain (stored as string to preserve precision)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      minAmount: string;
      /**
      * **earmarks.status**
      *
      * Earmark status: pending, ready, completed, cancelled (enforced by CHECK constraint)
      * - `text` in database
      * - `NOT NULL`, default: `'pending'::text`
      */
      status: string;
      /**
      * **earmarks.tickerHash**
      *
      * Token tickerHash (e.g., USDC, ETH) required for invoice payment
      * - `text` in database
      * - `NOT NULL`, no default
      */
      tickerHash: string;
      /**
      * **earmarks.updatedAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updatedAt: db.TimestampTzString | null;
    }
    export interface Whereable {
      /**
      * **earmarks.createdAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;
      /**
      * **earmarks.designatedPurchaseChain**
      *
      * Designated chain ID for purchasing this invoice - the invoice destination chain that Mark has identified as the target for fund aggregation
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      designatedPurchaseChain?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;
      /**
      * **earmarks.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **earmarks.invoiceId**
      *
      * External invoice identifier from the invoice processing system
      * - `text` in database
      * - `NOT NULL`, no default
      */
      invoiceId?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **earmarks.minAmount**
      *
      * Minimum amount of tokens required for invoice payment on the designated chain (stored as string to preserve precision)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      minAmount?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **earmarks.status**
      *
      * Earmark status: pending, ready, completed, cancelled (enforced by CHECK constraint)
      * - `text` in database
      * - `NOT NULL`, default: `'pending'::text`
      */
      status?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **earmarks.tickerHash**
      *
      * Token tickerHash (e.g., USDC, ETH) required for invoice payment
      * - `text` in database
      * - `NOT NULL`, no default
      */
      tickerHash?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **earmarks.updatedAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updatedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;
    }
    export interface Insertable {
      /**
      * **earmarks.createdAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment;
      /**
      * **earmarks.designatedPurchaseChain**
      *
      * Designated chain ID for purchasing this invoice - the invoice destination chain that Mark has identified as the target for fund aggregation
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      designatedPurchaseChain: number | db.Parameter<number> | db.SQLFragment;
      /**
      * **earmarks.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id?: string | db.Parameter<string> | db.DefaultType | db.SQLFragment;
      /**
      * **earmarks.invoiceId**
      *
      * External invoice identifier from the invoice processing system
      * - `text` in database
      * - `NOT NULL`, no default
      */
      invoiceId: string | db.Parameter<string> | db.SQLFragment;
      /**
      * **earmarks.minAmount**
      *
      * Minimum amount of tokens required for invoice payment on the designated chain (stored as string to preserve precision)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      minAmount: string | db.Parameter<string> | db.SQLFragment;
      /**
      * **earmarks.status**
      *
      * Earmark status: pending, ready, completed, cancelled (enforced by CHECK constraint)
      * - `text` in database
      * - `NOT NULL`, default: `'pending'::text`
      */
      status?: string | db.Parameter<string> | db.DefaultType | db.SQLFragment;
      /**
      * **earmarks.tickerHash**
      *
      * Token tickerHash (e.g., USDC, ETH) required for invoice payment
      * - `text` in database
      * - `NOT NULL`, no default
      */
      tickerHash: string | db.Parameter<string> | db.SQLFragment;
      /**
      * **earmarks.updatedAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updatedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment;
    }
    export interface Updatable {
      /**
      * **earmarks.createdAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment>;
      /**
      * **earmarks.designatedPurchaseChain**
      *
      * Designated chain ID for purchasing this invoice - the invoice destination chain that Mark has identified as the target for fund aggregation
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      designatedPurchaseChain?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;
      /**
      * **earmarks.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id?: string | db.Parameter<string> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.DefaultType | db.SQLFragment>;
      /**
      * **earmarks.invoiceId**
      *
      * External invoice identifier from the invoice processing system
      * - `text` in database
      * - `NOT NULL`, no default
      */
      invoiceId?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;
      /**
      * **earmarks.minAmount**
      *
      * Minimum amount of tokens required for invoice payment on the designated chain (stored as string to preserve precision)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      minAmount?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;
      /**
      * **earmarks.status**
      *
      * Earmark status: pending, ready, completed, cancelled (enforced by CHECK constraint)
      * - `text` in database
      * - `NOT NULL`, default: `'pending'::text`
      */
      status?: string | db.Parameter<string> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.DefaultType | db.SQLFragment>;
      /**
      * **earmarks.tickerHash**
      *
      * Token tickerHash (e.g., USDC, ETH) required for invoice payment
      * - `text` in database
      * - `NOT NULL`, no default
      */
      tickerHash?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;
      /**
      * **earmarks.updatedAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updatedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment>;
    }
    export type UniqueIndex = 'earmarks_pkey' | 'unique_invoice_id';
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;
    export type SQL = SQLExpression | SQLExpression[];
  }

  /**
   * **rebalance_operations**
   * - Table in database
   */
  export namespace rebalance_operations {
    export type Table = 'rebalance_operations';
    export interface Selectable {
      /**
      * **rebalance_operations.amount**
      *
      * Amount of tokens being rebalanced (stored as string to preserve precision)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      amount: string;
      /**
      * **rebalance_operations.bridge**
      *
      * Bridge adapter type used for this operation (e.g., across, binance)
      * - `text` in database
      * - Nullable, no default
      */
      bridge: string | null;
      /**
      * **rebalance_operations.createdAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      createdAt: Date | null;
      /**
      * **rebalance_operations.destinationChainId**
      *
      * Target chain ID where funds are being moved to
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      destinationChainId: number;
      /**
      * **rebalance_operations.earmarkId**
      *
      * Foreign key to the earmark this operation fulfills (NULL for regular rebalancing)
      * - `uuid` in database
      * - Nullable, no default
      */
      earmarkId: string | null;
      /**
      * **rebalance_operations.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id: string;
      /**
      * **rebalance_operations.originChainId**
      *
      * Source chain ID where funds are being moved from
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      originChainId: number;
      /**
      * **rebalance_operations.slippage**
      *
      * Expected slippage in basis points (e.g., 30 = 0.3%)
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      slippage: number;
      /**
      * **rebalance_operations.status**
      *
      * Operation status: pending, awaiting_callback, completed, expired (enforced by CHECK constraint)
      * - `text` in database
      * - `NOT NULL`, default: `'pending'::text`
      */
      status: string;
      /**
      * **rebalance_operations.tickerHash**
      * - `text` in database
      * - `NOT NULL`, no default
      */
      tickerHash: string;
      /**
      * **rebalance_operations.txHashes**
      *
      * Transaction hashes for cross-chain operations stored as JSON
      * - `jsonb` in database
      * - Nullable, default: `'{}'::jsonb`
      */
      txHashes: db.JSONValue | null;
      /**
      * **rebalance_operations.updatedAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updatedAt: Date | null;
    }
    export interface JSONSelectable {
      /**
      * **rebalance_operations.amount**
      *
      * Amount of tokens being rebalanced (stored as string to preserve precision)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      amount: string;
      /**
      * **rebalance_operations.bridge**
      *
      * Bridge adapter type used for this operation (e.g., across, binance)
      * - `text` in database
      * - Nullable, no default
      */
      bridge: string | null;
      /**
      * **rebalance_operations.createdAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      createdAt: db.TimestampTzString | null;
      /**
      * **rebalance_operations.destinationChainId**
      *
      * Target chain ID where funds are being moved to
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      destinationChainId: number;
      /**
      * **rebalance_operations.earmarkId**
      *
      * Foreign key to the earmark this operation fulfills (NULL for regular rebalancing)
      * - `uuid` in database
      * - Nullable, no default
      */
      earmarkId: string | null;
      /**
      * **rebalance_operations.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id: string;
      /**
      * **rebalance_operations.originChainId**
      *
      * Source chain ID where funds are being moved from
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      originChainId: number;
      /**
      * **rebalance_operations.slippage**
      *
      * Expected slippage in basis points (e.g., 30 = 0.3%)
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      slippage: number;
      /**
      * **rebalance_operations.status**
      *
      * Operation status: pending, awaiting_callback, completed, expired (enforced by CHECK constraint)
      * - `text` in database
      * - `NOT NULL`, default: `'pending'::text`
      */
      status: string;
      /**
      * **rebalance_operations.tickerHash**
      * - `text` in database
      * - `NOT NULL`, no default
      */
      tickerHash: string;
      /**
      * **rebalance_operations.txHashes**
      *
      * Transaction hashes for cross-chain operations stored as JSON
      * - `jsonb` in database
      * - Nullable, default: `'{}'::jsonb`
      */
      txHashes: db.JSONValue | null;
      /**
      * **rebalance_operations.updatedAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updatedAt: db.TimestampTzString | null;
    }
    export interface Whereable {
      /**
      * **rebalance_operations.amount**
      *
      * Amount of tokens being rebalanced (stored as string to preserve precision)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      amount?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **rebalance_operations.bridge**
      *
      * Bridge adapter type used for this operation (e.g., across, binance)
      * - `text` in database
      * - Nullable, no default
      */
      bridge?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **rebalance_operations.createdAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;
      /**
      * **rebalance_operations.destinationChainId**
      *
      * Target chain ID where funds are being moved to
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      destinationChainId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;
      /**
      * **rebalance_operations.earmarkId**
      *
      * Foreign key to the earmark this operation fulfills (NULL for regular rebalancing)
      * - `uuid` in database
      * - Nullable, no default
      */
      earmarkId?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **rebalance_operations.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **rebalance_operations.originChainId**
      *
      * Source chain ID where funds are being moved from
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      originChainId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;
      /**
      * **rebalance_operations.slippage**
      *
      * Expected slippage in basis points (e.g., 30 = 0.3%)
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      slippage?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;
      /**
      * **rebalance_operations.status**
      *
      * Operation status: pending, awaiting_callback, completed, expired (enforced by CHECK constraint)
      * - `text` in database
      * - `NOT NULL`, default: `'pending'::text`
      */
      status?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **rebalance_operations.tickerHash**
      * - `text` in database
      * - `NOT NULL`, no default
      */
      tickerHash?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **rebalance_operations.txHashes**
      *
      * Transaction hashes for cross-chain operations stored as JSON
      * - `jsonb` in database
      * - Nullable, default: `'{}'::jsonb`
      */
      txHashes?: db.JSONValue | db.Parameter<db.JSONValue> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, db.JSONValue | db.Parameter<db.JSONValue> | db.SQLFragment | db.ParentColumn>;
      /**
      * **rebalance_operations.updatedAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updatedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;
    }
    export interface Insertable {
      /**
      * **rebalance_operations.amount**
      *
      * Amount of tokens being rebalanced (stored as string to preserve precision)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      amount: string | db.Parameter<string> | db.SQLFragment;
      /**
      * **rebalance_operations.bridge**
      *
      * Bridge adapter type used for this operation (e.g., across, binance)
      * - `text` in database
      * - Nullable, no default
      */
      bridge?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;
      /**
      * **rebalance_operations.createdAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment;
      /**
      * **rebalance_operations.destinationChainId**
      *
      * Target chain ID where funds are being moved to
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      destinationChainId: number | db.Parameter<number> | db.SQLFragment;
      /**
      * **rebalance_operations.earmarkId**
      *
      * Foreign key to the earmark this operation fulfills (NULL for regular rebalancing)
      * - `uuid` in database
      * - Nullable, no default
      */
      earmarkId?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;
      /**
      * **rebalance_operations.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id?: string | db.Parameter<string> | db.DefaultType | db.SQLFragment;
      /**
      * **rebalance_operations.originChainId**
      *
      * Source chain ID where funds are being moved from
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      originChainId: number | db.Parameter<number> | db.SQLFragment;
      /**
      * **rebalance_operations.slippage**
      *
      * Expected slippage in basis points (e.g., 30 = 0.3%)
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      slippage: number | db.Parameter<number> | db.SQLFragment;
      /**
      * **rebalance_operations.status**
      *
      * Operation status: pending, awaiting_callback, completed, expired (enforced by CHECK constraint)
      * - `text` in database
      * - `NOT NULL`, default: `'pending'::text`
      */
      status?: string | db.Parameter<string> | db.DefaultType | db.SQLFragment;
      /**
      * **rebalance_operations.tickerHash**
      * - `text` in database
      * - `NOT NULL`, no default
      */
      tickerHash: string | db.Parameter<string> | db.SQLFragment;
      /**
      * **rebalance_operations.txHashes**
      *
      * Transaction hashes for cross-chain operations stored as JSON
      * - `jsonb` in database
      * - Nullable, default: `'{}'::jsonb`
      */
      txHashes?: db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment;
      /**
      * **rebalance_operations.updatedAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updatedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment;
    }
    export interface Updatable {
      /**
      * **rebalance_operations.amount**
      *
      * Amount of tokens being rebalanced (stored as string to preserve precision)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      amount?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;
      /**
      * **rebalance_operations.bridge**
      *
      * Bridge adapter type used for this operation (e.g., across, binance)
      * - `text` in database
      * - Nullable, no default
      */
      bridge?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;
      /**
      * **rebalance_operations.createdAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment>;
      /**
      * **rebalance_operations.destinationChainId**
      *
      * Target chain ID where funds are being moved to
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      destinationChainId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;
      /**
      * **rebalance_operations.earmarkId**
      *
      * Foreign key to the earmark this operation fulfills (NULL for regular rebalancing)
      * - `uuid` in database
      * - Nullable, no default
      */
      earmarkId?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;
      /**
      * **rebalance_operations.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id?: string | db.Parameter<string> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.DefaultType | db.SQLFragment>;
      /**
      * **rebalance_operations.originChainId**
      *
      * Source chain ID where funds are being moved from
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      originChainId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;
      /**
      * **rebalance_operations.slippage**
      *
      * Expected slippage in basis points (e.g., 30 = 0.3%)
      * - `int4` in database
      * - `NOT NULL`, no default
      */
      slippage?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;
      /**
      * **rebalance_operations.status**
      *
      * Operation status: pending, awaiting_callback, completed, expired (enforced by CHECK constraint)
      * - `text` in database
      * - `NOT NULL`, default: `'pending'::text`
      */
      status?: string | db.Parameter<string> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.DefaultType | db.SQLFragment>;
      /**
      * **rebalance_operations.tickerHash**
      * - `text` in database
      * - `NOT NULL`, no default
      */
      tickerHash?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;
      /**
      * **rebalance_operations.txHashes**
      *
      * Transaction hashes for cross-chain operations stored as JSON
      * - `jsonb` in database
      * - Nullable, default: `'{}'::jsonb`
      */
      txHashes?: db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment>;
      /**
      * **rebalance_operations.updatedAt**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updatedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment>;
    }
    export type UniqueIndex = 'rebalance_operations_pkey';
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;
    export type SQL = SQLExpression | SQLExpression[];
  }

  /**
   * **schema_migrations**
   * - Table in database
   */
  export namespace schema_migrations {
    export type Table = 'schema_migrations';
    export interface Selectable {
      /**
      * **schema_migrations.version**
      * - `varchar` in database
      * - `NOT NULL`, no default
      */
      version: string;
    }
    export interface JSONSelectable {
      /**
      * **schema_migrations.version**
      * - `varchar` in database
      * - `NOT NULL`, no default
      */
      version: string;
    }
    export interface Whereable {
      /**
      * **schema_migrations.version**
      * - `varchar` in database
      * - `NOT NULL`, no default
      */
      version?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
    }
    export interface Insertable {
      /**
      * **schema_migrations.version**
      * - `varchar` in database
      * - `NOT NULL`, no default
      */
      version: string | db.Parameter<string> | db.SQLFragment;
    }
    export interface Updatable {
      /**
      * **schema_migrations.version**
      * - `varchar` in database
      * - `NOT NULL`, no default
      */
      version?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;
    }
    export type UniqueIndex = 'schema_migrations_pkey';
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;
    export type SQL = SQLExpression | SQLExpression[];
  }

  /**
   * **transactions**
   * - Table in database
   */
  export namespace transactions {
    export type Table = 'transactions';
    export interface Selectable {
      /**
      * **transactions.chain_id**
      *
      * Chain ID where transaction occurred (stored as text for large chain IDs)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      chain_id: string;
      /**
      * **transactions.created_at**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      created_at: Date | null;
      /**
      * **transactions.cumulative_gas_used**
      *
      * Total gas used by transaction (stored as text for precision)
      * - `text` in database
      * - Nullable, no default
      */
      cumulative_gas_used: string | null;
      /**
      * **transactions.effective_gas_price**
      *
      * Effective gas price paid (stored as text for precision)
      * - `text` in database
      * - Nullable, no default
      */
      effective_gas_price: string | null;
      /**
      * **transactions.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id: string;
      /**
      * **transactions.metadata**
      *
      * Additional transaction-specific data stored as JSON
      * - `jsonb` in database
      * - Nullable, default: `'{}'::jsonb`
      */
      metadata: db.JSONValue | null;
      /**
      * **transactions.reason**
      *
      * Transaction purpose/category (e.g., deposit, withdrawal, bridge, etc.)
      * - `text` in database
      * - Nullable, no default
      */
      reason: string | null;
      /**
      * **transactions.rebalance_operation_id**
      *
      * Optional reference to associated rebalance operation (NULL for standalone transactions)
      * - `uuid` in database
      * - Nullable, no default
      */
      rebalance_operation_id: string | null;
      /**
      * **transactions.sender**
      *
      * Transaction sender address
      * - `text` in database
      * - Nullable, no default
      */
      sender: string | null;
      /**
      * **transactions.transaction_hash**
      *
      * On-chain transaction hash
      * - `text` in database
      * - `NOT NULL`, no default
      */
      transaction_hash: string;
      /**
      * **transactions.updated_at**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updated_at: Date | null;
    }
    export interface JSONSelectable {
      /**
      * **transactions.chain_id**
      *
      * Chain ID where transaction occurred (stored as text for large chain IDs)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      chain_id: string;
      /**
      * **transactions.created_at**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      created_at: db.TimestampTzString | null;
      /**
      * **transactions.cumulative_gas_used**
      *
      * Total gas used by transaction (stored as text for precision)
      * - `text` in database
      * - Nullable, no default
      */
      cumulative_gas_used: string | null;
      /**
      * **transactions.effective_gas_price**
      *
      * Effective gas price paid (stored as text for precision)
      * - `text` in database
      * - Nullable, no default
      */
      effective_gas_price: string | null;
      /**
      * **transactions.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id: string;
      /**
      * **transactions.metadata**
      *
      * Additional transaction-specific data stored as JSON
      * - `jsonb` in database
      * - Nullable, default: `'{}'::jsonb`
      */
      metadata: db.JSONValue | null;
      /**
      * **transactions.reason**
      *
      * Transaction purpose/category (e.g., deposit, withdrawal, bridge, etc.)
      * - `text` in database
      * - Nullable, no default
      */
      reason: string | null;
      /**
      * **transactions.rebalance_operation_id**
      *
      * Optional reference to associated rebalance operation (NULL for standalone transactions)
      * - `uuid` in database
      * - Nullable, no default
      */
      rebalance_operation_id: string | null;
      /**
      * **transactions.sender**
      *
      * Transaction sender address
      * - `text` in database
      * - Nullable, no default
      */
      sender: string | null;
      /**
      * **transactions.transaction_hash**
      *
      * On-chain transaction hash
      * - `text` in database
      * - `NOT NULL`, no default
      */
      transaction_hash: string;
      /**
      * **transactions.updated_at**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updated_at: db.TimestampTzString | null;
    }
    export interface Whereable {
      /**
      * **transactions.chain_id**
      *
      * Chain ID where transaction occurred (stored as text for large chain IDs)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      chain_id?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **transactions.created_at**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      created_at?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;
      /**
      * **transactions.cumulative_gas_used**
      *
      * Total gas used by transaction (stored as text for precision)
      * - `text` in database
      * - Nullable, no default
      */
      cumulative_gas_used?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **transactions.effective_gas_price**
      *
      * Effective gas price paid (stored as text for precision)
      * - `text` in database
      * - Nullable, no default
      */
      effective_gas_price?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **transactions.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **transactions.metadata**
      *
      * Additional transaction-specific data stored as JSON
      * - `jsonb` in database
      * - Nullable, default: `'{}'::jsonb`
      */
      metadata?: db.JSONValue | db.Parameter<db.JSONValue> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, db.JSONValue | db.Parameter<db.JSONValue> | db.SQLFragment | db.ParentColumn>;
      /**
      * **transactions.reason**
      *
      * Transaction purpose/category (e.g., deposit, withdrawal, bridge, etc.)
      * - `text` in database
      * - Nullable, no default
      */
      reason?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **transactions.rebalance_operation_id**
      *
      * Optional reference to associated rebalance operation (NULL for standalone transactions)
      * - `uuid` in database
      * - Nullable, no default
      */
      rebalance_operation_id?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **transactions.sender**
      *
      * Transaction sender address
      * - `text` in database
      * - Nullable, no default
      */
      sender?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **transactions.transaction_hash**
      *
      * On-chain transaction hash
      * - `text` in database
      * - `NOT NULL`, no default
      */
      transaction_hash?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;
      /**
      * **transactions.updated_at**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updated_at?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;
    }
    export interface Insertable {
      /**
      * **transactions.chain_id**
      *
      * Chain ID where transaction occurred (stored as text for large chain IDs)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      chain_id: string | db.Parameter<string> | db.SQLFragment;
      /**
      * **transactions.created_at**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      created_at?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment;
      /**
      * **transactions.cumulative_gas_used**
      *
      * Total gas used by transaction (stored as text for precision)
      * - `text` in database
      * - Nullable, no default
      */
      cumulative_gas_used?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;
      /**
      * **transactions.effective_gas_price**
      *
      * Effective gas price paid (stored as text for precision)
      * - `text` in database
      * - Nullable, no default
      */
      effective_gas_price?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;
      /**
      * **transactions.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id?: string | db.Parameter<string> | db.DefaultType | db.SQLFragment;
      /**
      * **transactions.metadata**
      *
      * Additional transaction-specific data stored as JSON
      * - `jsonb` in database
      * - Nullable, default: `'{}'::jsonb`
      */
      metadata?: db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment;
      /**
      * **transactions.reason**
      *
      * Transaction purpose/category (e.g., deposit, withdrawal, bridge, etc.)
      * - `text` in database
      * - Nullable, no default
      */
      reason?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;
      /**
      * **transactions.rebalance_operation_id**
      *
      * Optional reference to associated rebalance operation (NULL for standalone transactions)
      * - `uuid` in database
      * - Nullable, no default
      */
      rebalance_operation_id?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;
      /**
      * **transactions.sender**
      *
      * Transaction sender address
      * - `text` in database
      * - Nullable, no default
      */
      sender?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;
      /**
      * **transactions.transaction_hash**
      *
      * On-chain transaction hash
      * - `text` in database
      * - `NOT NULL`, no default
      */
      transaction_hash: string | db.Parameter<string> | db.SQLFragment;
      /**
      * **transactions.updated_at**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updated_at?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment;
    }
    export interface Updatable {
      /**
      * **transactions.chain_id**
      *
      * Chain ID where transaction occurred (stored as text for large chain IDs)
      * - `text` in database
      * - `NOT NULL`, no default
      */
      chain_id?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;
      /**
      * **transactions.created_at**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      created_at?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment>;
      /**
      * **transactions.cumulative_gas_used**
      *
      * Total gas used by transaction (stored as text for precision)
      * - `text` in database
      * - Nullable, no default
      */
      cumulative_gas_used?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;
      /**
      * **transactions.effective_gas_price**
      *
      * Effective gas price paid (stored as text for precision)
      * - `text` in database
      * - Nullable, no default
      */
      effective_gas_price?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;
      /**
      * **transactions.id**
      * - `uuid` in database
      * - `NOT NULL`, default: `uuid_generate_v4()`
      */
      id?: string | db.Parameter<string> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.DefaultType | db.SQLFragment>;
      /**
      * **transactions.metadata**
      *
      * Additional transaction-specific data stored as JSON
      * - `jsonb` in database
      * - Nullable, default: `'{}'::jsonb`
      */
      metadata?: db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment>;
      /**
      * **transactions.reason**
      *
      * Transaction purpose/category (e.g., deposit, withdrawal, bridge, etc.)
      * - `text` in database
      * - Nullable, no default
      */
      reason?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;
      /**
      * **transactions.rebalance_operation_id**
      *
      * Optional reference to associated rebalance operation (NULL for standalone transactions)
      * - `uuid` in database
      * - Nullable, no default
      */
      rebalance_operation_id?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;
      /**
      * **transactions.sender**
      *
      * Transaction sender address
      * - `text` in database
      * - Nullable, no default
      */
      sender?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;
      /**
      * **transactions.transaction_hash**
      *
      * On-chain transaction hash
      * - `text` in database
      * - `NOT NULL`, no default
      */
      transaction_hash?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;
      /**
      * **transactions.updated_at**
      * - `timestamptz` in database
      * - Nullable, default: `now()`
      */
      updated_at?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment>;
    }
    export type UniqueIndex = 'transactions_pkey' | 'unique_tx_chain';
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;
    export type SQL = SQLExpression | SQLExpression[];
  }

  /* --- aggregate types --- */

  export namespace public {  
    export type Table = earmarks.Table | rebalance_operations.Table | schema_migrations.Table | transactions.Table;
    export type Selectable = earmarks.Selectable | rebalance_operations.Selectable | schema_migrations.Selectable | transactions.Selectable;
    export type JSONSelectable = earmarks.JSONSelectable | rebalance_operations.JSONSelectable | schema_migrations.JSONSelectable | transactions.JSONSelectable;
    export type Whereable = earmarks.Whereable | rebalance_operations.Whereable | schema_migrations.Whereable | transactions.Whereable;
    export type Insertable = earmarks.Insertable | rebalance_operations.Insertable | schema_migrations.Insertable | transactions.Insertable;
    export type Updatable = earmarks.Updatable | rebalance_operations.Updatable | schema_migrations.Updatable | transactions.Updatable;
    export type UniqueIndex = earmarks.UniqueIndex | rebalance_operations.UniqueIndex | schema_migrations.UniqueIndex | transactions.UniqueIndex;
    export type Column = earmarks.Column | rebalance_operations.Column | schema_migrations.Column | transactions.Column;
  
    export type AllBaseTables = [earmarks.Table, rebalance_operations.Table, schema_migrations.Table, transactions.Table];
    export type AllForeignTables = [];
    export type AllViews = [];
    export type AllMaterializedViews = [];
    export type AllTablesAndViews = [earmarks.Table, rebalance_operations.Table, schema_migrations.Table, transactions.Table];
  }



  /* === global aggregate types === */

  export type Schema = 'public';
  export type Table = public.Table;
  export type Selectable = public.Selectable;
  export type JSONSelectable = public.JSONSelectable;
  export type Whereable = public.Whereable;
  export type Insertable = public.Insertable;
  export type Updatable = public.Updatable;
  export type UniqueIndex = public.UniqueIndex;
  export type Column = public.Column;

  export type AllSchemas = ['public'];
  export type AllBaseTables = [...public.AllBaseTables];
  export type AllForeignTables = [...public.AllForeignTables];
  export type AllViews = [...public.AllViews];
  export type AllMaterializedViews = [...public.AllMaterializedViews];
  export type AllTablesAndViews = [...public.AllTablesAndViews];


  /* === lookups === */

  export type SelectableForTable<T extends Table> = {
    "earmarks": earmarks.Selectable;
    "rebalance_operations": rebalance_operations.Selectable;
    "schema_migrations": schema_migrations.Selectable;
    "transactions": transactions.Selectable;
  }[T];

  export type JSONSelectableForTable<T extends Table> = {
    "earmarks": earmarks.JSONSelectable;
    "rebalance_operations": rebalance_operations.JSONSelectable;
    "schema_migrations": schema_migrations.JSONSelectable;
    "transactions": transactions.JSONSelectable;
  }[T];

  export type WhereableForTable<T extends Table> = {
    "earmarks": earmarks.Whereable;
    "rebalance_operations": rebalance_operations.Whereable;
    "schema_migrations": schema_migrations.Whereable;
    "transactions": transactions.Whereable;
  }[T];

  export type InsertableForTable<T extends Table> = {
    "earmarks": earmarks.Insertable;
    "rebalance_operations": rebalance_operations.Insertable;
    "schema_migrations": schema_migrations.Insertable;
    "transactions": transactions.Insertable;
  }[T];

  export type UpdatableForTable<T extends Table> = {
    "earmarks": earmarks.Updatable;
    "rebalance_operations": rebalance_operations.Updatable;
    "schema_migrations": schema_migrations.Updatable;
    "transactions": transactions.Updatable;
  }[T];

  export type UniqueIndexForTable<T extends Table> = {
    "earmarks": earmarks.UniqueIndex;
    "rebalance_operations": rebalance_operations.UniqueIndex;
    "schema_migrations": schema_migrations.UniqueIndex;
    "transactions": transactions.UniqueIndex;
  }[T];

  export type ColumnForTable<T extends Table> = {
    "earmarks": earmarks.Column;
    "rebalance_operations": rebalance_operations.Column;
    "schema_migrations": schema_migrations.Column;
    "transactions": transactions.Column;
  }[T];

  export type SQLForTable<T extends Table> = {
    "earmarks": earmarks.SQL;
    "rebalance_operations": rebalance_operations.SQL;
    "schema_migrations": schema_migrations.SQL;
    "transactions": transactions.SQL;
  }[T];

}
