{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Database Schema Setup and Migration",
        "description": "Create PostgreSQL database schema with earmarks, rebalance_operations, and earmark_audit_log tables including proper indexing strategy",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Create three main tables: 1) earmarks table with id (UUID), invoiceId, destinationChainId, ticker, invoiceAmount, status fields 2) rebalance_operations table with earmarkId foreign key, origin/destination chain info, amounts, slippage, status, and transaction hashes 3) earmark_audit_log table for audit trail. Implement indexing on earmarks.invoiceId, earmarks.destinationChainId+ticker, rebalance_operations.earmarkId, and composite index on earmarks.status+destinationChainId. Set up connection pooling, transaction isolation, and database migration scripts.",
        "testStrategy": "Unit tests for database connection, schema validation, index performance testing, transaction rollback scenarios, and data consistency checks",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up database adapter package structure",
            "description": "Create packages/adapters/database folder structure mirroring packages/adapters/cache pattern with proper TypeScript configuration",
            "dependencies": [],
            "details": "Create packages/adapters/database directory structure with src/, test/, and db/ folders. Copy and adapt package.json, tsconfig.json from cache adapter. Create db/ subdirectory for dbmate migrations and schema.sql. Set up npm scripts for database operations including 'db:create', 'db:migrate', 'db:rollback'. Configure TypeScript build process and module exports.\n<info added on 2025-07-22T20:46:49.818Z>\nPackage structure implementation completed successfully. Directory structure created with all required folders (src/, test/, db/), package.json configured with dbmate and zapatos dependencies, TypeScript and Jest configurations set up, basic connection module and types implemented, test framework initialized, and README documentation provided. All files follow cache adapter pattern for consistency. Database adapter package is ready for dbmate installation and configuration.\n</info added on 2025-07-22T20:46:49.818Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Install and configure dbmate for migrations",
            "description": "Install dbmate and configure it for PostgreSQL migrations",
            "details": "Install dbmate as a dev dependency in package.json. Configure dbmate to use packages/adapters/database/db/migrations as migration directory. Set up package.json scripts (db:create, db:migrate, db:rollback, db:new) for workspace compatibility. Ensure proper PostgreSQL connection configuration using environment variables passed at runtime.",
            "status": "done",
            "dependencies": [
              1
            ],
            "parentTaskId": 1
          },
          {
            "id": 3,
            "title": "Create initial schema.sql with table definitions",
            "description": "Write the complete PostgreSQL schema with earmarks, rebalance_operations, and earmark_audit_log tables",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Create packages/adapters/database/db/schema.sql with CREATE TABLE statements for: earmarks (id UUID PRIMARY KEY, invoiceId TEXT, destinationChainId INT, ticker TEXT, invoiceAmount NUMERIC, status TEXT, created_at TIMESTAMP), rebalance_operations (id UUID PRIMARY KEY, earmarkId UUID REFERENCES earmarks, originChainId INT, amounts JSONB, slippage NUMERIC, status TEXT, txHashes JSONB), earmark_audit_log (id SERIAL PRIMARY KEY, earmarkId UUID, operation TEXT, details JSONB, timestamp TIMESTAMP).\n<info added on 2025-07-22T21:23:46.574Z>\nImplementation Status Update: Successfully completed dbmate configuration and setup. Created dbmate.yaml configuration file with proper directory structure (migrations_dir: ./db/migrations, schema_file: ./db/schema.sql). Verified npm package dependencies and scripts are correctly configured (db:create, db:migrate, db:rollback, db:status, db:new). Updated project documentation with dbmate workflow commands. Confirmed dbmate is properly configured to use DATABASE_URL environment variable for database connections. Tested dbmate installation and functionality - all systems operational. Ready to proceed with migration file generation.\n</info added on 2025-07-22T21:23:46.574Z>",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Generate initial migration with indexing strategy",
            "description": "Create dbmate migration file implementing the schema with all required indexes for performance optimization",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Run dbmate new create_earmark_tables to generate migration file. Copy schema from schema.sql into up migration. Add CREATE INDEX statements: idx_earmarks_invoiceId ON earmarks(invoiceId), idx_earmarks_chain_ticker ON earmarks(destinationChainId, ticker), idx_rebalance_operations_earmarkId ON rebalance_operations(earmarkId), idx_earmarks_status_chain ON earmarks(status, destinationChainId). Write down migration with proper DROP statements in reverse order.\n<info added on 2025-07-22T21:20:09.196Z>\nSchema creation completed with comprehensive table structure and indexing. Ready to proceed with migration file generation using dbmate new create_earmark_tables command.\n</info added on 2025-07-22T21:20:09.196Z>",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Configure zapatos for TypeScript client generation",
            "description": "Set up zapatos to generate type-safe PostgreSQL client from the database schema",
            "status": "done",
            "dependencies": [
              4
            ],
            "details": "Create .zapatosrc.json configuration file in packages/adapters/database pointing to DATABASE_URL environment variable. Run zapatos to generate TypeScript types from existing migration schema. Add npm script 'db:generate-types' that runs zapatos after migrations. Enhance existing src/db.ts to integrate zapatos typed queries and exports. Set up workflow to automatically regenerate types after migrations in development process.\n<info added on 2025-07-22T23:42:19.634Z>\nConfiguration file name correction: Use zapatosconfig.json instead of .zapatosrc.json. The config should specify db.connectionString pointing to DATABASE_URL and outDir set to ./src for proper type generation location.\n</info added on 2025-07-22T23:42:19.634Z>\n<info added on 2025-07-22T23:47:05.976Z>\nSuccessfully configured zapatos TypeScript client generation. Generated type-safe database interfaces for all schema tables (earmarks, rebalance_operations, earmark_audit_log). Enhanced db.ts module with zapatos-powered query functions for complete CRUD operations across all tables. Implemented transaction wrapper withTransaction() for atomic operations. Added proper connection management and error handling. All TypeScript types compile successfully, providing full type safety for database operations.\n</info added on 2025-07-22T23:47:05.976Z>",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create database adapter module exports and tests",
            "description": "Implement the main adapter module with connection management, exports, and basic connectivity tests",
            "status": "done",
            "dependencies": [
              5
            ],
            "details": "Create src/index.ts exporting database pool, typed tables, and utility functions. Implement connection health check, retry logic, and graceful shutdown. Create test/adapter.test.ts with basic connectivity tests, migration verification, and type generation validation. Add README.md documenting database setup, migration workflow, and zapatos usage. Ensure module integrates cleanly with existing project structure.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Core Database Operations Layer",
        "description": "Implement database CRUD operations for earmark management with transaction support and error handling",
        "details": "Implement createEarmark(), getEarmarks(), getEarmarkForInvoice(), removeEarmark() functions with proper PostgreSQL integration. Add getAvailableForOnDemandSource() and getEarmarkedAmount() functions that calculate available balances while respecting reserves and current invoice requirements. Include atomic operations for creating earmarks with multiple rebalance operations, proper error handling, connection retry logic, and audit logging for all state changes.",
        "testStrategy": "Unit tests for each CRUD operation, integration tests with PostgreSQL, transaction rollback testing, concurrent access testing, and performance benchmarking for high-volume scenarios",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Core Earmark CRUD Operations",
            "description": "Create the fundamental database operations for earmark management including createEarmark, getEarmarks, getEarmarkForInvoice, and removeEarmark with proper transaction support",
            "dependencies": [],
            "details": "Implement createEarmark() with atomic transaction support for creating earmark records and associated rebalance_operations in a single transaction. Add getEarmarks() with efficient filtering by status, destinationChainId, and ticker using prepared statements and proper indexing. Create getEarmarkForInvoice() with unique constraint enforcement and proper error handling for missing records. Implement removeEarmark() with cascading cleanup of associated rebalance_operations and audit log entries. Use pg-promise or similar for connection pooling and transaction management.\n<info added on 2025-07-23T00:31:07.847Z>\nImplementation completed successfully. Created 4 core CRUD functions: createEarmark (with atomic transactions), getEarmarks (with flexible filtering), getEarmarkForInvoice (with unique constraint checking), and removeEarmark (with cascading cleanup). All functions include proper audit logging and comprehensive test coverage. Code follows TypeScript strict typing rules and passes linting checks.\n</info added on 2025-07-23T00:31:07.847Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Build Balance Calculation Functions",
            "description": "Implement getAvailableForOnDemandSource and getEarmarkedAmount functions that accurately calculate available balances while respecting reserves and earmarks",
            "dependencies": [
              "2.1"
            ],
            "details": "Create getAvailableForOnDemandSource() that calculates true available balance by subtracting earmarked amounts and required reserves from total balance. Implement getEarmarkedAmount() to aggregate all active earmarks for a given chainId and ticker combination. Add support for slippage calculations in balance determinations. Ensure functions handle concurrent access patterns correctly with appropriate isolation levels. Include reserve threshold configurations and validation logic.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Atomic Multi-Source Transaction Patterns",
            "description": "Create transaction patterns for atomic multi-source earmark creation with proper rollback mechanisms and isolation levels",
            "dependencies": [
              "2.1"
            ],
            "details": "Design transaction wrapper functions that handle creating an earmark with multiple rebalance_operations atomically. Implement proper isolation levels (SERIALIZABLE for critical operations) to prevent race conditions. Add savepoint support for partial rollbacks within larger transactions. Create retry logic with exponential backoff for transient failures. Include deadlock detection and resolution strategies for concurrent earmark creation scenarios.\n<info added on 2025-07-23T00:46:38.558Z>\nImplementation completed successfully. Achieved comprehensive transaction framework including withAdvancedTransaction function with configurable isolation levels (SERIALIZABLE for critical operations to prevent race conditions), savepoint mechanism for granular partial rollbacks within larger transactions, exponential backoff retry logic with intelligent deadlock detection and resolution, createMultiSourceEarmark function for atomic multi-chain earmark operations, and withMonitoredTransaction wrapper for performance tracking and metrics collection. Error handling system properly categorizes all database errors (DeadlockError, SerializationError, ConnectionError) as retryable vs non-retryable with appropriate retry strategies. Implementation passes all linting checks and includes comprehensive test coverage for transaction isolation, deadlock scenarios, partial rollback functionality, and concurrent operation handling.\n</info added on 2025-07-23T00:46:38.558Z>\n<info added on 2025-07-23T01:12:40.130Z>\nTask approach updated to reflect blockchain-first submission pattern. Focus shifted from complex atomic multi-source earmark creation to simpler patterns:\n\n1. Basic connection pooling with retry logic for network failures\n2. Simple transaction wrappers for related database updates after blockchain submission\n3. Idempotent update patterns for handling blockchain event processing\n4. Standard database error handling without complex rollback mechanisms\n\nRemoved emphasis on SERIALIZABLE isolation levels, savepoints for partial rollbacks, and pre-commitment transaction phases since operations will record blockchain submissions rather than create complex earmarks beforehand. Implementation maintains retry logic and error categorization but eliminates deadlock resolution strategies for concurrent earmark creation as this complexity is no longer needed with the new submission-first approach.\n</info added on 2025-07-23T01:12:40.130Z>\n<info added on 2025-07-23T01:26:09.148Z>\nSimplification process completed successfully with transition to blockchain-first recording pattern. Eliminated complex multi-source earmark creation functionality, SERIALIZABLE isolation levels, and savepoint mechanisms as they are unnecessary with post-submission recording approach. Refactored transaction patterns to focus on simple blockchain operation recording functions with proper error handling and type safety. All test suites now pass with the simplified architecture that records blockchain submissions after they occur rather than managing complex pre-commitment transaction phases.\n</info added on 2025-07-23T01:26:09.148Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add Comprehensive Error Handling Layer",
            "description": "Implement robust error handling for database operations, business logic violations, and network failures with proper error categorization",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3"
            ],
            "details": "Create custom error classes for different failure scenarios: DatabaseError, BusinessLogicError, ConcurrencyError, ValidationError. Implement error recovery strategies including connection retry with circuit breaker pattern, transaction rollback with state cleanup, and partial failure handling for multi-chain operations. Add detailed error logging with context preservation. Include error metrics collection for monitoring integration.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Build Audit Logging System",
            "description": "Implement comprehensive audit logging for all earmark state changes and rebalancing operations with proper event tracking",
            "dependencies": [
              "2.1",
              "2.3"
            ],
            "details": "Create audit log triggers or application-level logging for all CRUD operations on earmarks and rebalance_operations tables. Implement structured logging with operation type, before/after states, user context, and timestamps. Add correlation IDs for tracking related operations across multiple tables. Include audit log retention policies and archival strategies. Build query interfaces for audit trail analysis and compliance reporting.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement TTL and Cleanup Mechanisms",
            "description": "Create TTL management system for earmarks with automatic cleanup of stale records and failed operations",
            "dependencies": [
              "2.1",
              "2.5"
            ],
            "details": "Implement background job or trigger-based system for earmark expiration based on configurable TTL values. Create cleanup procedures for orphaned rebalance_operations and incomplete earmarks. Add status transition logic for timeout scenarios (PENDING -> EXPIRED). Implement soft-delete patterns with purge scheduling for audit compliance. Include monitoring for cleanup job health and performance metrics.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create Business Logic Validation Layer",
            "description": "Implement comprehensive validation for earmark creation, updates, and state transitions with referential integrity checks",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "Build validation functions for earmark amount limits, destination chain validity, and ticker support verification. Implement state machine validation for allowed status transitions. Add referential integrity checks beyond database constraints for business rules. Create validation for sufficient source liquidity before earmark creation. Include cross-chain validation for rebalance operation feasibility.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Optimize Query Performance and Indexing",
            "description": "Implement query optimization strategies, batch operations, and enhanced indexing for high-volume scenarios",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "Create batch insert/update operations for multiple earmarks using COPY commands or multi-row inserts. Implement query plan analysis and optimization for complex joins between earmarks and rebalance_operations. Add partial indexes for common query patterns (e.g., active earmarks only). Create materialized views for expensive aggregation queries. Include query performance monitoring and slow query logging.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Enhance Connection Pool Management",
            "description": "Implement advanced connection pooling with health checks, retry logic, and failover support for database resilience",
            "dependencies": [
              "2.1",
              "2.4"
            ],
            "details": "Configure connection pool with appropriate size limits based on expected concurrency. Implement connection health checks with automatic bad connection eviction. Add connection retry logic with exponential backoff and jitter. Create failover support for read replicas in case of primary database issues. Include connection pool metrics for monitoring (active, idle, waiting connections).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Build Integration Testing Framework",
            "description": "Create comprehensive integration testing suite for concurrent access patterns, high-volume scenarios, and edge cases",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3",
              "2.4"
            ],
            "details": "Implement concurrent access tests simulating multiple invoice processors creating earmarks simultaneously. Create high-volume performance tests with thousands of earmarks and rebalance operations. Add edge case testing for database connection failures, transaction timeouts, and partial operation completions. Include data consistency validation tests across related tables. Build test fixtures and data generators for realistic scenarios.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Add Monitoring and Health Check Integration",
            "description": "Implement monitoring endpoints and health checks for database operations layer with metrics collection",
            "dependencies": [
              "2.1",
              "2.6",
              "2.8",
              "2.9"
            ],
            "details": "Create health check endpoints validating database connectivity, query performance, and cleanup job status. Implement metrics collection for operation latencies, error rates, and throughput. Add custom Prometheus metrics for earmark creation rate, TTL expiration rate, and balance calculation performance. Include alerting thresholds for critical metrics. Build dashboard templates for operational visibility.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "Create Type Definitions and Documentation",
            "description": "Implement complete TypeScript type definitions and comprehensive documentation for the database operations layer",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3",
              "2.7"
            ],
            "details": "Create detailed TypeScript interfaces for all database entities, function parameters, and return types. Add JSDoc comments for all public functions with usage examples. Build API documentation using TypeDoc or similar tools. Include architecture diagrams showing transaction flows and state transitions. Create operational runbooks for common maintenance tasks and troubleshooting procedures.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "On-Demand Rebalancing Core Logic",
        "description": "Implement onDemand.ts with evaluation, execution, and processing functions for automated rebalancing decisions",
        "details": "Create evaluateOnDemandRebalancing() to determine rebalancing feasibility considering slippage, reserves, and multi-chain coordination. Implement executeOnDemandRebalancing() to create rebalancing transactions and database earmarks. Build processEarmarkedInvoices() to check completion status and prepare intents for batching. Include destination optimization logic that minimizes rebalance operations and amounts, with proper slippage calculations and all-or-nothing completion validation.",
        "testStrategy": "Unit tests for each function with mock scenarios, integration tests with database layer, slippage calculation validation, multi-chain coordination testing, and edge case handling for invoice state changes",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Multi-Chain Rebalancing Coordination",
        "description": "Implement coordinated multi-source rebalancing with composite earmark tracking and all-or-nothing completion logic",
        "details": "Build destination analysis system that evaluates multiple potential destination chains using requiredRebalanceOps, totalRebalanceAmount, and feasibility criteria. Implement selectOptimalDestination() with primary criteria of minimizing rebalance operations and secondary criteria of minimizing total amounts. Add coordinated multi-chain rebalancing that tracks multiple RebalanceOperation entries under single earmark with proper completion validation using isRebalancingComplete(). Ensure chosen destination becomes origin chain for invoice purchase allocation.",
        "testStrategy": "Integration tests for multi-chain scenarios, destination selection algorithm validation, partial failure recovery testing, timing variation handling, and end-to-end multi-source rebalancing workflows",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Integration with processInvoices.ts",
        "description": "Integrate on-demand rebalancing into existing invoice processing workflow with three-phase approach",
        "details": "Phase 1 (Pre-processing): Add checks for earmarked invoices at start of processing, validate rebalancing completion, handle invoice amount changes, prepare intents for completed rebalances. Phase 2 (Processing): Detect insufficient balances and trigger on-demand evaluation, execute rebalancing when viable. Phase 3 (Post-processing): Clean up completed earmarks, handle failures, log audit trails. Ensure earmarked funds are properly reserved by modifying getAvailableBalance() to subtract earmarked amounts and prevent conflicts with regular processing.",
        "testStrategy": "Integration tests with existing processInvoices.ts workflow, FIFO ordering validation, earmark reservation testing, conflict resolution between regular and on-demand rebalancing, and full end-to-end invoice processing scenarios",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Error Handling and Monitoring",
        "description": "Implement comprehensive error handling, audit logging, and operational monitoring for on-demand rebalancing system",
        "details": "Add robust error handling for database failures, network issues, partial multi-chain failures with proper rollback procedures. Implement comprehensive audit logging using earmark_audit_log table for all state changes, rebalancing operations, and fund movements. Create monitoring for invoice fulfillment rate improvement, rebalancing completion times, multi-chain success rates, and database performance metrics. Include cleanup procedures for failed operations, timeout mechanisms for stuck rebalances, and alerting for system reliability issues.",
        "testStrategy": "Error injection testing for database and network failures, audit log completeness validation, monitoring metric accuracy testing, cleanup procedure verification, timeout handling validation, and operational reliability stress testing",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-22T20:23:01.952Z",
      "updated": "2025-07-23T00:46:11.139Z",
      "description": "Tasks for master context"
    }
  }
}