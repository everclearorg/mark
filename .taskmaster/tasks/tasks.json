{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Database Schema Setup and Migration",
        "description": "Create PostgreSQL database schema with earmarks, rebalance_operations, and earmark_audit_log tables including proper indexing strategy",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Create three main tables: 1) earmarks table with id (UUID), invoiceId, destinationChainId, ticker, invoiceAmount, status fields 2) rebalance_operations table with earmarkId foreign key, origin/destination chain info, amounts, slippage, status, and transaction hashes 3) earmark_audit_log table for audit trail. Implement indexing on earmarks.invoiceId, earmarks.destinationChainId+ticker, rebalance_operations.earmarkId, and composite index on earmarks.status+destinationChainId. Set up connection pooling, transaction isolation, and database migration scripts.",
        "testStrategy": "Unit tests for database connection, schema validation, index performance testing, transaction rollback scenarios, and data consistency checks",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up database adapter package structure",
            "description": "Create packages/adapters/database folder structure mirroring packages/adapters/cache pattern with proper TypeScript configuration",
            "dependencies": [],
            "details": "Create packages/adapters/database directory structure with src/, test/, and db/ folders. Copy and adapt package.json, tsconfig.json from cache adapter. Create db/ subdirectory for dbmate migrations and schema.sql. Set up npm scripts for database operations including 'db:create', 'db:migrate', 'db:rollback'. Configure TypeScript build process and module exports.\n<info added on 2025-07-22T20:46:49.818Z>\nPackage structure implementation completed successfully. Directory structure created with all required folders (src/, test/, db/), package.json configured with dbmate and zapatos dependencies, TypeScript and Jest configurations set up, basic connection module and types implemented, test framework initialized, and README documentation provided. All files follow cache adapter pattern for consistency. Database adapter package is ready for dbmate installation and configuration.\n</info added on 2025-07-22T20:46:49.818Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Install and configure dbmate for migrations",
            "description": "Install dbmate and configure it for PostgreSQL migrations",
            "details": "Install dbmate as a dev dependency in package.json. Configure dbmate to use packages/adapters/database/db/migrations as migration directory. Set up package.json scripts (db:create, db:migrate, db:rollback, db:new) for workspace compatibility. Ensure proper PostgreSQL connection configuration using environment variables passed at runtime.",
            "status": "done",
            "dependencies": [
              1
            ],
            "parentTaskId": 1
          },
          {
            "id": 3,
            "title": "Create initial schema.sql with table definitions",
            "description": "Write the complete PostgreSQL schema with earmarks, rebalance_operations, and earmark_audit_log tables",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Create packages/adapters/database/db/schema.sql with CREATE TABLE statements for: earmarks (id UUID PRIMARY KEY, invoiceId TEXT, destinationChainId INT, ticker TEXT, invoiceAmount NUMERIC, status TEXT, created_at TIMESTAMP), rebalance_operations (id UUID PRIMARY KEY, earmarkId UUID REFERENCES earmarks, originChainId INT, amounts JSONB, slippage NUMERIC, status TEXT, txHashes JSONB), earmark_audit_log (id SERIAL PRIMARY KEY, earmarkId UUID, operation TEXT, details JSONB, timestamp TIMESTAMP).\n<info added on 2025-07-22T21:23:46.574Z>\nImplementation Status Update: Successfully completed dbmate configuration and setup. Created dbmate.yaml configuration file with proper directory structure (migrations_dir: ./db/migrations, schema_file: ./db/schema.sql). Verified npm package dependencies and scripts are correctly configured (db:create, db:migrate, db:rollback, db:status, db:new). Updated project documentation with dbmate workflow commands. Confirmed dbmate is properly configured to use DATABASE_URL environment variable for database connections. Tested dbmate installation and functionality - all systems operational. Ready to proceed with migration file generation.\n</info added on 2025-07-22T21:23:46.574Z>",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Generate initial migration with indexing strategy",
            "description": "Create dbmate migration file implementing the schema with all required indexes for performance optimization",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Run dbmate new create_earmark_tables to generate migration file. Copy schema from schema.sql into up migration. Add CREATE INDEX statements: idx_earmarks_invoiceId ON earmarks(invoiceId), idx_earmarks_chain_ticker ON earmarks(destinationChainId, ticker), idx_rebalance_operations_earmarkId ON rebalance_operations(earmarkId), idx_earmarks_status_chain ON earmarks(status, destinationChainId). Write down migration with proper DROP statements in reverse order.\n<info added on 2025-07-22T21:20:09.196Z>\nSchema creation completed with comprehensive table structure and indexing. Ready to proceed with migration file generation using dbmate new create_earmark_tables command.\n</info added on 2025-07-22T21:20:09.196Z>",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Configure zapatos for TypeScript client generation",
            "description": "Set up zapatos to generate type-safe PostgreSQL client from the database schema",
            "status": "done",
            "dependencies": [
              4
            ],
            "details": "Create .zapatosrc.json configuration file in packages/adapters/database pointing to DATABASE_URL environment variable. Run zapatos to generate TypeScript types from existing migration schema. Add npm script 'db:generate-types' that runs zapatos after migrations. Enhance existing src/db.ts to integrate zapatos typed queries and exports. Set up workflow to automatically regenerate types after migrations in development process.\n<info added on 2025-07-22T23:42:19.634Z>\nConfiguration file name correction: Use zapatosconfig.json instead of .zapatosrc.json. The config should specify db.connectionString pointing to DATABASE_URL and outDir set to ./src for proper type generation location.\n</info added on 2025-07-22T23:42:19.634Z>\n<info added on 2025-07-22T23:47:05.976Z>\nSuccessfully configured zapatos TypeScript client generation. Generated type-safe database interfaces for all schema tables (earmarks, rebalance_operations, earmark_audit_log). Enhanced db.ts module with zapatos-powered query functions for complete CRUD operations across all tables. Implemented transaction wrapper withTransaction() for atomic operations. Added proper connection management and error handling. All TypeScript types compile successfully, providing full type safety for database operations.\n</info added on 2025-07-22T23:47:05.976Z>",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create database adapter module exports and tests",
            "description": "Implement the main adapter module with connection management, exports, and basic connectivity tests",
            "status": "done",
            "dependencies": [
              5
            ],
            "details": "Create src/index.ts exporting database pool, typed tables, and utility functions. Implement connection health check, retry logic, and graceful shutdown. Create test/adapter.test.ts with basic connectivity tests, migration verification, and type generation validation. Add README.md documenting database setup, migration workflow, and zapatos usage. Ensure module integrates cleanly with existing project structure.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Core Database Operations Layer",
        "description": "Implement database CRUD operations for earmark management with transaction support and error handling",
        "details": "Implement createEarmark(), getEarmarks(), getEarmarkForInvoice(), removeEarmark() functions with proper PostgreSQL integration. Add getAvailableForOnDemandSource() and getEarmarkedAmount() functions that calculate available balances while respecting reserves and current invoice requirements. Include atomic operations for creating earmarks with multiple rebalance operations, proper error handling, connection retry logic, and audit logging for all state changes.",
        "testStrategy": "Unit tests for each CRUD operation, integration tests with PostgreSQL, transaction rollback testing, concurrent access testing, and performance benchmarking for high-volume scenarios",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "On-Demand Rebalancing Core Logic",
        "description": "Implement onDemand.ts with evaluation, execution, and processing functions for automated rebalancing decisions",
        "details": "Create evaluateOnDemandRebalancing() to determine rebalancing feasibility considering slippage, reserves, and multi-chain coordination. Implement executeOnDemandRebalancing() to create rebalancing transactions and database earmarks. Build processEarmarkedInvoices() to check completion status and prepare intents for batching. Include destination optimization logic that minimizes rebalance operations and amounts, with proper slippage calculations and all-or-nothing completion validation.",
        "testStrategy": "Unit tests for each function with mock scenarios, integration tests with database layer, slippage calculation validation, multi-chain coordination testing, and edge case handling for invoice state changes",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Multi-Chain Rebalancing Coordination",
        "description": "Implement coordinated multi-source rebalancing with composite earmark tracking and all-or-nothing completion logic",
        "details": "Build destination analysis system that evaluates multiple potential destination chains using requiredRebalanceOps, totalRebalanceAmount, and feasibility criteria. Implement selectOptimalDestination() with primary criteria of minimizing rebalance operations and secondary criteria of minimizing total amounts. Add coordinated multi-chain rebalancing that tracks multiple RebalanceOperation entries under single earmark with proper completion validation using isRebalancingComplete(). Ensure chosen destination becomes origin chain for invoice purchase allocation.",
        "testStrategy": "Integration tests for multi-chain scenarios, destination selection algorithm validation, partial failure recovery testing, timing variation handling, and end-to-end multi-source rebalancing workflows",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Integration with processInvoices.ts",
        "description": "Integrate on-demand rebalancing into existing invoice processing workflow with three-phase approach",
        "details": "Phase 1 (Pre-processing): Add checks for earmarked invoices at start of processing, validate rebalancing completion, handle invoice amount changes, prepare intents for completed rebalances. Phase 2 (Processing): Detect insufficient balances and trigger on-demand evaluation, execute rebalancing when viable. Phase 3 (Post-processing): Clean up completed earmarks, handle failures, log audit trails. Ensure earmarked funds are properly reserved by modifying getAvailableBalance() to subtract earmarked amounts and prevent conflicts with regular processing.",
        "testStrategy": "Integration tests with existing processInvoices.ts workflow, FIFO ordering validation, earmark reservation testing, conflict resolution between regular and on-demand rebalancing, and full end-to-end invoice processing scenarios",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Error Handling and Monitoring",
        "description": "Implement comprehensive error handling, audit logging, and operational monitoring for on-demand rebalancing system",
        "details": "Add robust error handling for database failures, network issues, partial multi-chain failures with proper rollback procedures. Implement comprehensive audit logging using earmark_audit_log table for all state changes, rebalancing operations, and fund movements. Create monitoring for invoice fulfillment rate improvement, rebalancing completion times, multi-chain success rates, and database performance metrics. Include cleanup procedures for failed operations, timeout mechanisms for stuck rebalances, and alerting for system reliability issues.",
        "testStrategy": "Error injection testing for database and network failures, audit log completeness validation, monitoring metric accuracy testing, cleanup procedure verification, timeout handling validation, and operational reliability stress testing",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-22T20:23:01.952Z",
      "updated": "2025-07-23T00:05:28.822Z",
      "description": "Tasks for master context"
    }
  }
}