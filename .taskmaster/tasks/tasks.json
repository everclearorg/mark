{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Database Schema Setup and Migration",
        "description": "Create PostgreSQL database schema with earmarks, rebalance_operations, and earmark_audit_log tables including proper indexing strategy",
        "details": "Create three main tables: 1) earmarks table with id (UUID), invoiceId, destinationChainId, ticker, invoiceAmount, status fields 2) rebalance_operations table with earmarkId foreign key, origin/destination chain info, amounts, slippage, status, and transaction hashes 3) earmark_audit_log table for audit trail. Implement indexing on earmarks.invoiceId, earmarks.destinationChainId+ticker, rebalance_operations.earmarkId, and composite index on earmarks.status+destinationChainId. Set up connection pooling, transaction isolation, and database migration scripts.",
        "testStrategy": "Unit tests for database connection, schema validation, index performance testing, transaction rollback scenarios, and data consistency checks",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up database adapter package structure",
            "description": "Create packages/adapters/database folder structure mirroring packages/adapters/cache pattern with proper TypeScript configuration",
            "dependencies": [],
            "details": "Create packages/adapters/database directory structure with src/, test/, and db/ folders. Copy and adapt package.json, tsconfig.json from cache adapter. Create db/ subdirectory for dbmate migrations and schema.sql. Set up npm scripts for database operations including 'db:create', 'db:migrate', 'db:rollback'. Configure TypeScript build process and module exports.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Install and configure dbmate for migrations",
            "description": "Set up dbmate as the migration tool with proper configuration for PostgreSQL connection and migration paths",
            "dependencies": [
              "1.1"
            ],
            "details": "Install dbmate as a dev dependency. Create .env.example with DATABASE_URL template. Configure dbmate to use packages/adapters/database/db/migrations as migration directory. Create dbmate scripts in package.json for new migration creation, up/down operations. Set up GitHub Actions workflow for migration validation in CI.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create initial schema.sql with table definitions",
            "description": "Write the complete PostgreSQL schema with earmarks, rebalance_operations, and earmark_audit_log tables",
            "dependencies": [
              "1.1"
            ],
            "details": "Create packages/adapters/database/db/schema.sql with CREATE TABLE statements for: earmarks (id UUID PRIMARY KEY, invoiceId TEXT, destinationChainId INT, ticker TEXT, invoiceAmount NUMERIC, status TEXT, created_at TIMESTAMP), rebalance_operations (id UUID PRIMARY KEY, earmarkId UUID REFERENCES earmarks, originChainId INT, amounts JSONB, slippage NUMERIC, status TEXT, txHashes JSONB), earmark_audit_log (id SERIAL PRIMARY KEY, earmarkId UUID, operation TEXT, details JSONB, timestamp TIMESTAMP).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Generate initial migration with indexing strategy",
            "description": "Create dbmate migration file implementing the schema with all required indexes for performance optimization",
            "dependencies": [
              "1.2",
              "1.3"
            ],
            "details": "Run dbmate new create_earmark_tables to generate migration file. Copy schema from schema.sql into up migration. Add CREATE INDEX statements: idx_earmarks_invoiceId ON earmarks(invoiceId), idx_earmarks_chain_ticker ON earmarks(destinationChainId, ticker), idx_rebalance_operations_earmarkId ON rebalance_operations(earmarkId), idx_earmarks_status_chain ON earmarks(status, destinationChainId). Write down migration with proper DROP statements in reverse order.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Configure zapatos for TypeScript client generation",
            "description": "Set up zapatos to generate type-safe PostgreSQL client from the database schema",
            "dependencies": [
              "1.4"
            ],
            "details": "Install zapatos and pg as dependencies. Create zapatos configuration file pointing to DATABASE_URL. Add npm script 'db:generate-types' that runs zapatos to generate TypeScript types from schema. Create src/db.ts that exports configured zapatos pool and typed query functions. Set up automatic type regeneration after migrations in development workflow.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create database adapter module exports and tests",
            "description": "Implement the main adapter module with connection management, exports, and basic connectivity tests",
            "dependencies": [
              "1.5"
            ],
            "details": "Create src/index.ts exporting database pool, typed tables, and utility functions. Implement connection health check, retry logic, and graceful shutdown. Create test/adapter.test.ts with basic connectivity tests, migration verification, and type generation validation. Add README.md documenting database setup, migration workflow, and zapatos usage. Ensure module integrates cleanly with existing project structure.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Core Database Operations Layer",
        "description": "Implement database CRUD operations for earmark management with transaction support and error handling",
        "details": "Implement createEarmark(), getEarmarks(), getEarmarkForInvoice(), removeEarmark() functions with proper PostgreSQL integration. Add getAvailableForOnDemandSource() and getEarmarkedAmount() functions that calculate available balances while respecting reserves and current invoice requirements. Include atomic operations for creating earmarks with multiple rebalance operations, proper error handling, connection retry logic, and audit logging for all state changes.",
        "testStrategy": "Unit tests for each CRUD operation, integration tests with PostgreSQL, transaction rollback testing, concurrent access testing, and performance benchmarking for high-volume scenarios",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "On-Demand Rebalancing Core Logic",
        "description": "Implement onDemand.ts with evaluation, execution, and processing functions for automated rebalancing decisions",
        "details": "Create evaluateOnDemandRebalancing() to determine rebalancing feasibility considering slippage, reserves, and multi-chain coordination. Implement executeOnDemandRebalancing() to create rebalancing transactions and database earmarks. Build processEarmarkedInvoices() to check completion status and prepare intents for batching. Include destination optimization logic that minimizes rebalance operations and amounts, with proper slippage calculations and all-or-nothing completion validation.",
        "testStrategy": "Unit tests for each function with mock scenarios, integration tests with database layer, slippage calculation validation, multi-chain coordination testing, and edge case handling for invoice state changes",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Multi-Chain Rebalancing Coordination",
        "description": "Implement coordinated multi-source rebalancing with composite earmark tracking and all-or-nothing completion logic",
        "details": "Build destination analysis system that evaluates multiple potential destination chains using requiredRebalanceOps, totalRebalanceAmount, and feasibility criteria. Implement selectOptimalDestination() with primary criteria of minimizing rebalance operations and secondary criteria of minimizing total amounts. Add coordinated multi-chain rebalancing that tracks multiple RebalanceOperation entries under single earmark with proper completion validation using isRebalancingComplete(). Ensure chosen destination becomes origin chain for invoice purchase allocation.",
        "testStrategy": "Integration tests for multi-chain scenarios, destination selection algorithm validation, partial failure recovery testing, timing variation handling, and end-to-end multi-source rebalancing workflows",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Integration with processInvoices.ts",
        "description": "Integrate on-demand rebalancing into existing invoice processing workflow with three-phase approach",
        "details": "Phase 1 (Pre-processing): Add checks for earmarked invoices at start of processing, validate rebalancing completion, handle invoice amount changes, prepare intents for completed rebalances. Phase 2 (Processing): Detect insufficient balances and trigger on-demand evaluation, execute rebalancing when viable. Phase 3 (Post-processing): Clean up completed earmarks, handle failures, log audit trails. Ensure earmarked funds are properly reserved by modifying getAvailableBalance() to subtract earmarked amounts and prevent conflicts with regular processing.",
        "testStrategy": "Integration tests with existing processInvoices.ts workflow, FIFO ordering validation, earmark reservation testing, conflict resolution between regular and on-demand rebalancing, and full end-to-end invoice processing scenarios",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Error Handling and Monitoring",
        "description": "Implement comprehensive error handling, audit logging, and operational monitoring for on-demand rebalancing system",
        "details": "Add robust error handling for database failures, network issues, partial multi-chain failures with proper rollback procedures. Implement comprehensive audit logging using earmark_audit_log table for all state changes, rebalancing operations, and fund movements. Create monitoring for invoice fulfillment rate improvement, rebalancing completion times, multi-chain success rates, and database performance metrics. Include cleanup procedures for failed operations, timeout mechanisms for stuck rebalances, and alerting for system reliability issues.",
        "testStrategy": "Error injection testing for database and network failures, audit log completeness validation, monitoring metric accuracy testing, cleanup procedure verification, timeout handling validation, and operational reliability stress testing",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-22T20:23:01.952Z",
      "updated": "2025-07-22T20:23:01.952Z",
      "description": "Tasks for master context"
    }
  }
}